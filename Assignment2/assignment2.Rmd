---
title: "Assignment 2 - Network Modeling"
subtitle: "Group 5"
author: 
- Lorenzo Benedetti (23-956-451)
- Francesco Freni (23-955-248)
- Aristotelis Koutris (23-942-683)
- Ruben Oliveira Rodrigues (21-922-042)
date: "`r Sys.Date()`"
output: pdf_document
header-includes: 
  - \usepackage{amsmath}
  - \usepackage{graphicx}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(RSiena)
library(sna)
source('printSiena.R')
```


## Task 1 
(1) 
\begin{itemize}
\item Out-degree: 
  \begin{align*}
    s_{1i}(x) = \sum_{j}x_{ij}
  \end{align*}
\item Reciprocity:
  \begin{align*}
    s_{2i}(x) = \sum_{j}x_{ij}x_{ji}
  \end{align*}
\item Transitive reciprocated triplets effect:
  \begin{align*}
    s_{3i}(x) = \sum_{j,h}x_{ij}x_{ji}x_{ih}x_{hj}
  \end{align*}
\item Same covariate effect:
  \begin{align*}
    s_{4i}(x) = \sum_{j}x_{ij}I\{v_i = v_j\}
  \end{align*}
\end{itemize}


(2)
(i) Actor c can either add a tie to b, remove the tie to a, add a tie to d or keep the network unchanged.
\begin{figure}[ht!]
\begin{center}
\includegraphics[width=0.6\textwidth]{images/1.jpg}
\end{center}
\label{fig:1}
\end{figure}

\begin{align*}
 \resizebox{1\textwidth}{!}{$
  \frac{exp(-1.5\times 2 + 2\times 1 + 1\times 1 + 1.5\times 0)}{exp(-1.5\times 2 + 2\times 1 + 1\times 1 + 1.5\times 0) + exp(-1.5\times 0 + 2\times 0 + 1\times 0 + 1.5\times 0) + exp(-1.5\times 2 + 2\times 0 + 1\times 0 + 1.5\times 1) + exp(-1.5\times 1 + 2\times 0 + 1\times 0 + 1.5\times 0)} = 0.4087872$}
\end{align*}

(ii) Actor b can either add a tie to a, remove the tie to c, add a tie to d or keep the network unchanged.
\begin{figure}[ht!]
\begin{center}
\includegraphics[width=0.6\textwidth]{images/2.jpg}
\end{center}
\label{fig:2}
\end{figure}

\begin{align*}
 \resizebox{1\textwidth}{!}{$
  \frac{exp(-1.5\times 2 + 2\times 1 + 1\times 1 + 1.5\times 1)}{exp(-1.5\times 2 + 2\times 1 + 1\times 1 + 1.5\times 1) + exp(-1.5\times 0 + 2\times 0 + 1\times 0 + 1.5\times 0) + exp(-1.5\times 2 + 2\times 1 + 1\times 0 + 1.5\times 0) + exp(-1.5\times 1 + 2\times 0 + 1\times 0 + 1.5\times 0)} = 0.7380062$}
\end{align*}

(iii) Actor a can either remove the tie to b, add a tie to c, remove the tie to d or keep the network unchanged.
\begin{figure}[ht!]
\begin{center}
\includegraphics[width=0.6\textwidth]{images/3.jpg}
\end{center}
\label{fig:3}
\end{figure}

\begin{align*}
 \resizebox{1\textwidth}{!}{$
  \frac{exp(-1.5\times 1 + 2\times 1 + 1\times 0 + 1.5\times 0)}{exp(-1.5\times 1 + 2\times 1 + 1\times 0 + 1.5\times 0) + exp(-1.5\times 3 + 2\times 2 + 1\times 1 + 1.5\times 1) + exp(-1.5\times 1 + 2\times 0 + 1\times 0 + 1.5\times 1) + exp(-1.5\times 2 + 2\times 1 + 1\times 0 + 1.5\times 1)} = 0.1410791$}
\end{align*}

(iv) Actor a can either remove the tie to a, remove the tie to b, add a tie to c or keep the network unchanged.
\begin{figure}[ht!]
\begin{center}
\includegraphics[width=0.6\textwidth]{images/4.jpg}
\end{center}
\label{fig:4}
\end{figure}

\begin{align*}
 \resizebox{1\textwidth}{!}{$
  \frac{exp(-1.5\times 2 + 2\times 1 + 1\times 0 + 1.5\times 0)}{exp(-1.5\times 1 + 2\times 0 + 1\times 0 + 1.5\times 0) + exp(-1.5\times 1 + 2\times 1 + 1\times 0 + 1.5\times 0) + exp(-1.5\times 3 + 2\times 1 + 1\times 1 + 1.5\times 1) + exp(-1.5\times 2 + 2\times 1 + 1\times 0 + 1.5\times 0)} = 0.1135525$}
\end{align*}


## Task 2
(1)
```{r}
# Task 2.1 ----------------------------------------------------------------
# The function "simulation" simulates the network evolution between 
# two time points. 
# Given the network at time t1, denoted by x1, the function simulates the 
# steps of the continuous-time Markov chain defined by a SAOM with outdegree,
# recip and transTrip statistics. Unconditional simulation is used.
# The function returns the network at time t2.
# The structure of the algorithm is described in the file
# _Simulating from SAOM.pdf_ available in
# the Lecture notes and additional material section on Moodle.

#' Simulate the network evolution between two time points
#'
#' @param n number of actors in the network
#' @param x1 network at time t1
#' @param lambda rate parameter
#' @param beta1 outdegree parameter
#' @param beta2 reciprocity parameter
#' @param beta3 transTrip parameter
#'
#' @return network at time t2
#'
#' @examples
#' netT1 <- matrix(c(
#'   0, 1, 0, 0, 0,
#'   0, 0, 0, 1, 0,
#'   0, 0, 0, 1, 1,
#'   1, 0, 1, 0, 0,
#'   0, 1, 1, 0, 1
#'   ), 
#'   nrow = 5, ncol =  5, byrow = TRUE)
#' netT2 <- simulation(5, netT1, 4, -2, 0.5, 0.05)
simulation <- function(n, x1, lambda, beta1, beta2, beta3) {
  t <- 0 # time
  x <- x1
  while (t < 1) {
    dt <- rexp(1, n * lambda)
    i <- sample(1:n, size=1)
    
    delta_outdegree <- rep(0, n)
    delta_rec <- rep(0, n)
    delta_trans_trip <- rep(0, n)
    for (j in (1:n)) {
      if (j==i) next
      delta_outdegree[j] <- 1 - 2*x[i,j]
      delta_rec[j] <- (1 - x[i,j])*x[j,i] - x[i,j]*x[j,i]
      #if ((x[i,j]==1) & (x[j,i]==1)) {
      #  delta_rec[j] <- -1
      #} else if (x[j,i] == 1) {
      #  delta_rec[j] <- 1
      #}
      for (h in 1:n) {
        delta_trans_trip[j] <- delta_trans_trip[j] + (1-x[i,j])*x[i,h]*x[h,j] -
          x[i,j]*x[i,h]*x[h,j]
        delta_trans_trip[j] <- delta_trans_trip[j] + x[i,h]*(1-x[i,j])*x[j,h] -
          x[i,h]*x[i,j]*x[j,h]
      }
    }
    p <- exp(beta1 * delta_outdegree + beta2 * delta_rec + beta3 * delta_trans_trip) /
      sum(exp(beta1 * delta_outdegree + beta2 * delta_rec + beta3 * delta_trans_trip))
    j <- which.max(rmultinom(1, 1, prob = p))
    if (i != j) x[i,j] <- 1 - x[i,j]
    t <- t + dt
  }
  return(x)
}
```


(2)
```{r}
net1 <- as.matrix(read.csv('net1.csv', header=F))
net2 <- as.matrix(read.csv('net2.csv', header=F))

waves <- sienaDependent(array(c(net1, net2), dim=c(22, 22, 2)))
myData <- sienaDataCreate(waves)
myData
```

```{r}
myeff <- getEffects(myData)
myeff <- includeEffects(myeff, transTrip)

myAlgorithm <- sienaAlgorithmCreate(
  nsub = 2, n3 = 3000, seed = 2023
)

model0 <- siena07(myAlgorithm,
  data = myData, effects = myeff, returnDeps = TRUE,
  useCluster = TRUE, nbrNodes = 4
)
model0
```
```{r}
(lambda <- model0$rate)
(beta <- model0$theta)
```

(3)
```{r}
set.seed(2023)
nsim <- 1000
triadCensus <- matrix(NA, nrow=nsim, ncol=16) # 16 types of triads
for (i in 1:nsim) {
  x2sim <- simulation(nrow(net1), net1, lambda, beta[1], beta[2], beta[3])
  triadCensus[i,] <- triad.census(x2sim, mode = 'digraph')
}
```

(4)
```{r}
## i. standardized the simulated network stats. ----
##   Name the resulting object as triadCensusStd
stdev <- apply(triadCensus, 2, sd)
m <- apply(triadCensus, 2, mean)
triadCensusStd <- sapply(1:length(m), function(x) (triadCensus[,x] - m[x])/stdev[x])

## ii. variance-covariance matrix and its generalized inverse.         ----
Phatinv <- MASS::ginv(cov(triadCensusStd))

## iii. standardized the observed values of the triad census counts    ----
##  in the second observation using values from i.
net2std <- sapply(1:length(m), function(x) (triad.census(net2)[,x] - m[x])/stdev[x])
names(net2std) <- 1:16

## iv. Monte-Carlo Mahalanobis distance computation                                ----
# Compute the Mahalanobis distance using the mhd function for 
# the auxiliar statistics of the simulated networks and the observed network.
# Remember to drop statistics with variance of 0 for the plot and
# Mahalanobis distance computation, report which statistics suffer this issue.

#' Compute the Mahalanobis distance
#'
#' @param auxStats numerical vector with the mean centered or standardized
#'   auxiliar statistics
#' @param invCov numerical matrix with the inverse of the variance-covariance
#'   matrix of the auxiliar statistics in the simulated networks
#'
#' @return numeric value with the Mahalanobis distance of auxiliar stats
#'
#' @examples
#' mhd(c(2, 4) - c(1.5, 2), solve(matrix(c(1, 0.8, 0.8, 1), ncol = 2)))
mhd <- function(auxStats, invCov) {
  t(auxStats) %*% invCov %*% auxStats
}

triadCensusStd <- triadCensusStd[,stdev>0]
mhd_sim <- apply(triadCensusStd, 1, function(x) mhd(x, Phatinv))
mhd_obs <- mhd(net2std, Phatinv)

## v. Monte-Carlo p-value computation                                ----
# Compute the proportion of simulated networks where the distance is 
# equal or greater than the distance in the observed network.
mean(mhd_sim >= mhd)

# violin plots ------------------------------------------------------------
# Fill out the missing part and run the code to obtain the violin plots

# install.packages(c("tidyverse", "ggplot2"))  # # run this line to install 
library(tidyverse)  # used: dplyr and tidyr
library(ggplot2)

# Given the array triadCensusStd, create a data frame from it in a long format, 
# do the same for the observed network statistics at time t2.
# Named the data frame "triadCensusDf" and "triadCensusObs".
# Drops statistics with variance of 0 for the plot.

triadCensusDf <- data.frame(triadCensusStd) |>
  select(where(~ var(.) > 0)) |>  # Drop statistics with zero variance
  pivot_longer(
    everything(),
    names_to = "triad", names_pattern = "^X(.+)$",
    values_to = "nnodes"
  )

# Compute the statistics of the observed network at time t2,
#  standardized using the stats from 2.4 literal i.
triadCensusObs <- # ---MISSING--- |> 
  data.frame(t(net2std)) |>
  pivot_longer(
    everything(),
    names_to = "triad", names_pattern = "^X(.+)$",
    values_to = "nnodes"
  ) |>
  filter(triad %in% unique(triadCensusDf$triad))

# The following code computes the 5% and the 95% quantiles
# of the triad counts by type
percTriad <- triadCensusDf |>
  group_by(triad) |>
  summarise(
    quant05 = quantile(nnodes, prob = 0.05),
    quant95 = quantile(nnodes, prob = 0.95)
  ) |>
  pivot_longer(
    starts_with("quant"),
    names_to = "quant", names_pattern = "quant(.+)",
    values_to = "nnodes"
  )


# The following code produces the violin plots
ggplot(triadCensusDf, aes(fct_inorder(triad), nnodes)) +
  geom_violin(trim = FALSE, scale = "width") +
  stat_summary(fun = mean, geom = "point", size = 2) +
  geom_boxplot(width = 0.2, fill = "gray", outlier.shape = 4) +
  geom_point(data = triadCensusObs, col = "red", size = 2) +
  geom_line(
    data = triadCensusObs, aes(group = 1), col = "red", linewidth = 0.5
  ) +
  geom_line(
    data = percTriad, mapping = aes(group = quant),
    col = "gray", linetype = "dashed"
  ) +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.y = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  ) +
  xlab("triad type")

```

The p-value computed in (4) suggests that the model has a good fit. Considering the plot, \textcolor{red}{MISSING} observed values are outside the $95\%$ confidence intervals, but overall we conclude that the fit is decent. 


## Task 3
(1)
(1.1)
```{r}
f1 <- as.matrix(read.csv("f1.csv", header = FALSE))
f2 <- as.matrix(read.csv("f2.csv", header = FALSE))
f3 <- as.matrix(read.csv("f3.csv", header = FALSE))
attributes <- read.csv("demographic.csv", header = TRUE)
logdistance <- as.matrix(read.csv("logdistance.csv", header = FALSE))
alcohol <- as.matrix(read.csv('alcohol.csv', header = T))

friendship <- sienaDependent(
  array(c(f1, f2, f3), dim = c(129, 129, 3))
)

gender <- coCovar(attributes$gender)
age <- coCovar(attributes$age)
logdistance <- coDyadCovar(logdistance)
alcohol <- varCovar(alcohol)

mydata <- sienaDataCreate(friendship, gender, age, logdistance, alcohol)
print01Report(mydata, modelname='Glasgow')
```

```{r}
# Tie changes between subsequent observations:
#  periods        0 =>  0   0 =>  1   1 =>  0   1 =>  1   Distance Jaccard   Missing
#   1 ==>   2     15827       237       240       208       477     0.304         0 (0%)
#   2 ==>   3     15839       228       209       236       437     0.351         0 (0%)
```

The Jaccard Index is above $0.3$ in both periods, so the data contains enough information to investigate the evolution of the friendship network.

(1.2)
```{r}
myeff <- getEffects(mydata)
myAlgorithm <- sienaAlgorithmCreate(
  projname = "friends_res",
  nsub = 4, n3 = 1000, seed = 1908
)
myeff <- includeEffects(myeff, transTrip)
myeff <- includeEffects(myeff, inPop)
myeff <- includeEffects(myeff, egoX, altX, simX, interaction1='alcohol')
myeff <- includeEffects(myeff, X, interaction1='logdistance')
```

(1.3)
```{r}
modelEv <- siena07(
  myAlgorithm,
  data = mydata, effects = myeff,
  returnDeps = TRUE,
  useCluster = TRUE, nbrNodes = 4
)
modelEv
```
```{r}
printSiena(modelEv)
```

The algorithm converged, because the absolute value of the maximum t-ratio of all the parameters is below $0.1$ and the overall maximum convergence ratio is below $0.2$. All the included parameters are significant, except for the control effects (alcohol ego and alcohol alter).
The density parameter is negative, as we expected from a social network (sparse network). The positive reciprocity parameter suggests that an actor tends to reciprocate a friendship nomination. The negative logdistance parameter suggests that there is a negative correlation between distance between students and tendency to form a tie.
The positive indegree polutarity suggests that there is a tendency to nominate as a friend a popular student (high in-degree). 
The positive alcohol similarity effect suggests that students with similar alcohol consumption tend to be friends.

