---
title: "Assignment 2 - Network Modeling"
subtitle: "Group 5"
author: 
- Lorenzo Benedetti (23-956-451)
- Francesco Freni (23-955-248)
- Aristotelis Koutris (23-942-683)
- Ruben Oliveira Rodrigues (21-922-042)
date: "`r Sys.Date()`"
output: pdf_document
header-includes: 
  - \usepackage{amsmath}
  - \usepackage{graphicx}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(RSiena)
library(sna)
library(parallel)
source('printSiena.R')
```

## Task 1

(1) 

    ```{=tex}
    \begin{itemize}
    \item Out-degree: 
      \begin{align*}
    s_{1i}(x) = \sum_{j}x_{ij}
      \end{align*}
    \item Reciprocity:
      \begin{align*}
    s_{2i}(x) = \sum_{j}x_{ij}x_{ji}
      \end{align*}
    \item Transitive reciprocated triplets effect:
      \begin{align*}
    s_{3i}(x) = \sum_{j,h}x_{ij}x_{ji}x_{ih}x_{hj}
      \end{align*}
    \item Same covariate effect:
      \begin{align*}
    s_{4i}(x) = \sum_{j}x_{ij}I\{v_i = v_j\}
      \end{align*}
    \end{itemize}
    ```

(2) 

<!-- -->

(i) Actor c can either add a tie to b, remove the tie to a, add a tie to d or keep the network unchanged.

    ```{=tex}
    \begin{figure}[ht!]
    \begin{center}
    \includegraphics[width=0.6\textwidth]{images/1.jpg}
    \end{center}
    \label{fig:1}
    \end{figure}
    ```

```{=tex}
\begin{align*}
 \resizebox{1\textwidth}{!}{$
  \frac{exp(-1.5\times 2 + 2\times 1 + 1\times 1 + 1.5\times 0)}{exp(-1.5\times 2 + 2\times 1 + 1\times 1 + 1.5\times 0) + exp(-1.5\times 0 + 2\times 0 + 1\times 0 + 1.5\times 0) + exp(-1.5\times 2 + 2\times 0 + 1\times 0 + 1.5\times 1) + exp(-1.5\times 1 + 2\times 0 + 1\times 0 + 1.5\times 0)} = 0.4087872$}
\end{align*}
```
(ii) Actor b can either add a tie to a, remove the tie to c, add a tie to d or keep the network unchanged.

     ```{=tex}
     \begin{figure}[ht!]
     \begin{center}
     \includegraphics[width=0.6\textwidth]{images/2.jpg}
     \end{center}
     \label{fig:2}
     \end{figure}
     ```

```{=tex}
\begin{align*}
 \resizebox{1\textwidth}{!}{$
  \frac{exp(-1.5\times 2 + 2\times 1 + 1\times 1 + 1.5\times 1)}{exp(-1.5\times 2 + 2\times 1 + 1\times 1 + 1.5\times 1) + exp(-1.5\times 0 + 2\times 0 + 1\times 0 + 1.5\times 0) + exp(-1.5\times 2 + 2\times 1 + 1\times 0 + 1.5\times 0) + exp(-1.5\times 1 + 2\times 0 + 1\times 0 + 1.5\times 0)} = 0.7380062$}
\end{align*}
```
(iii) Actor a can either remove the tie to b, add a tie to c, remove the tie to d or keep the network unchanged.

      ```{=tex}
      \begin{figure}[ht!]
      \begin{center}
      \includegraphics[width=0.6\textwidth]{images/3.jpg}
      \end{center}
      \label{fig:3}
      \end{figure}
      ```

```{=tex}
\begin{align*}
 \resizebox{1\textwidth}{!}{$
  \frac{exp(-1.5\times 1 + 2\times 1 + 1\times 0 + 1.5\times 0)}{exp(-1.5\times 1 + 2\times 1 + 1\times 0 + 1.5\times 0) + exp(-1.5\times 3 + 2\times 2 + 1\times 1 + 1.5\times 1) + exp(-1.5\times 1 + 2\times 0 + 1\times 0 + 1.5\times 1) + exp(-1.5\times 2 + 2\times 1 + 1\times 0 + 1.5\times 1)} = 0.1410791$}
\end{align*}
```
(iv) Actor a can either remove the tie to a, remove the tie to b, add a tie to c or keep the network unchanged.

     ```{=tex}
     \begin{figure}[ht!]
     \begin{center}
     \includegraphics[width=0.6\textwidth]{images/4.jpg}
     \end{center}
     \label{fig:4}
     \end{figure}
     ```

```{=tex}
\begin{align*}
 \resizebox{1\textwidth}{!}{$
  \frac{exp(-1.5\times 2 + 2\times 1 + 1\times 0 + 1.5\times 0)}{exp(-1.5\times 1 + 2\times 0 + 1\times 0 + 1.5\times 0) + exp(-1.5\times 1 + 2\times 1 + 1\times 0 + 1.5\times 0) + exp(-1.5\times 3 + 2\times 1 + 1\times 1 + 1.5\times 1) + exp(-1.5\times 2 + 2\times 1 + 1\times 0 + 1.5\times 0)} = 0.1135525$}
\end{align*}
```
## Task 2

(1) 

```{r, cache=TRUE}
# Task 2.1 ----------------------------------------------------------------
# The function "simulation" simulates the network evolution between 
# two time points. 
# Given the network at time t1, denoted by x1, the function simulates the 
# steps of the continuous-time Markov chain defined by a SAOM with outdegree,
# recip and transTrip statistics. Unconditional simulation is used.
# The function returns the network at time t2.
# The structure of the algorithm is described in the file
# _Simulating from SAOM.pdf_ available in
# the Lecture notes and additional material section on Moodle.

#' Simulate the network evolution between two time points
#'
#' @param n number of actors in the network
#' @param x1 network at time t1
#' @param lambda rate parameter
#' @param beta1 outdegree parameter
#' @param beta2 reciprocity parameter
#' @param beta3 transTrip parameter
#'
#' @return network at time t2
#'
#' @examples
#' netT1 <- matrix(c(
#'   0, 1, 0, 0, 0,
#'   0, 0, 0, 1, 0,
#'   0, 0, 0, 1, 1,
#'   1, 0, 1, 0, 0,
#'   0, 1, 1, 0, 1
#'   ), 
#'   nrow = 5, ncol =  5, byrow = TRUE)
#' netT2 <- simulation(5, netT1, 4, -2, 0.5, 0.05)
simulation <- function(n, x1, lambda, beta1, beta2, beta3) {
  t <- 0 # time
  x <- x1
  while (t < 1) {
    dt <- rexp(1, n * lambda)
    i <- sample(1:n, size=1)
    
    delta_outdegree <- rep(0, n)
    delta_rec <- rep(0, n)
    delta_trans_trip <- rep(0, n)
    
    for (j in (1:n)) {
      if (j==i) next
      
      delta_outdegree[j] <- 1 - 2*x[i,j]
      delta_rec[j] <- (1 - 2*x[i,j])*x[j,i]
      delta_trans_trip[j] <- (1 - 2*x[i,j]) * x[i,] %*% (x[,j] + x[j,])
    }
    
    p <- exp(beta1 * delta_outdegree + beta2 * delta_rec + beta3 * delta_trans_trip) /
      sum(exp(beta1 * delta_outdegree + beta2 * delta_rec + beta3 * delta_trans_trip))
    j <- which.max(rmultinom(1, 1, prob = p))
    if (i != j) x[i,j] <- 1 - x[i,j]
    t <- t+dt
  }
  return(x)
}
```
Assuming the tie $i \rightarrow j$ is toggled, only one value in the adjacency matrix is going to change: $x[i, j]$ becomes $1 - x[i, j]$. 

**Change in outdegree**: The outdegree of node $i$ is the sum of the elements of the $i$th row of the adjacency matrix and the only term of the sum that changes is $x[i,j]$. It follows that the delta of the outdegree is $(1 - x[i,j]) - x[i,j] = 1 - 2x[i,j]$. 

**Change in reciprocated pairs**: The number of reciprocated pairs is given by $\sum_{a< b}x[a,b] \cdot x[b,a]$: the only term that changes by toggling edge $i \rightarrow j$ corresponds to $\{a ,b \} = \{ i, j \}$. Therefore, the delta of the number of reciprocated pairs is $(1 - x[i, j]) \cdot x[j,i] - x[i,j] \cdot x[j,i] = (1 - 2x[i,j]) \cdot x[j,i]$.

**Change in transitive triplets**: The number of transitive reciprocated triplets is given by $\sum_{a, b, c} x[a, c] \cdot x[c, b] \cdot x[a, b]$. There are two type of terms that change by toggling edge $i \rightarrwo j$: those of the form $x[i, j] \cdot x[j,h] \cdot x[i, h]$, i.e. the added/removed edge adds/removes a $2$-path; those of the form $x[i, h] \cdot x[h, j] \cdot x[i, j]$, ie.e the added/removed edge closes/opens a $2$-path. Therefore, the total delta is given by $$\sum_{h} (1 - 2x[i,j]) \cdot x[j,h] \cdot x[i, h] + \sum_{h} x[i, h] \cdot x[h, j] \cdot (1 - 2x[i, j]) = \\ (1-2x[i,j]) \sum_{h}x[i,h] \cdot (x[j, h] + x[h, j])$$.

(2) 

```{r, cache=TRUE}
net1 <- as.matrix(read.csv('net1.csv', header=F))
net2 <- as.matrix(read.csv('net2.csv', header=F))

waves <- sienaDependent(array(c(net1, net2), dim=c(22, 22, 2)))
myData <- sienaDataCreate(waves)
myData
```

```{r, cache=TRUE}
myeff <- getEffects(myData)
myeff <- includeEffects(myeff, transTrip)

myAlgorithm <- sienaAlgorithmCreate(
  nsub = 2, n3 = 3000, seed = 2023
)

model0 <- siena07(myAlgorithm,
  data = myData, effects = myeff, returnDeps = TRUE,
  useCluster = TRUE, nbrNodes = 4
)
model0
```

```{r}
(lambda <- model0$rate)
(beta <- model0$theta)
```

(3) 

```{r, cache=TRUE}
set.seed(2023)
nsim <- 1000
triadCensus <- matrix(NA, nrow=nsim, ncol=16) # 16 types of triads
for (i in 1:nsim) {
  x2sim <- simulation(nrow(net1), net1, lambda, beta[1], beta[2], beta[3])
  triadCensus[i,] <- triad.census(x2sim, mode = 'digraph')
}
```

(4) 

```{r, cache=TRUE}
## i. standardized the simulated network stats. ----
##   Name the resulting object as triadCensusStd
stdev <- apply(triadCensus, 2, sd)
m <- apply(triadCensus, 2, mean)
triadCensusStd <- sapply(1:length(m), function(x) (triadCensus[,x] - m[x])/stdev[x])

## ii. variance-covariance matrix and its generalized inverse.         ----
Phatinv <- MASS::ginv(cov(triadCensusStd))

## iii. standardized the observed values of the triad census counts    ----
##  in the second observation using values from i.
net2std <- sapply(1:length(m), function(x) (triad.census(net2)[,x] - m[x])/stdev[x])
names(net2std) <- 1:16

## iv. Monte-Carlo Mahalanobis distance computation                                ----
# Compute the Mahalanobis distance using the mhd function for 
# the auxiliar statistics of the simulated networks and the observed network.
# Remember to drop statistics with variance of 0 for the plot and
# Mahalanobis distance computation, report which statistics suffer this issue.

#' Compute the Mahalanobis distance
#'
#' @param auxStats numerical vector with the mean centered or standardized
#'   auxiliar statistics
#' @param invCov numerical matrix with the inverse of the variance-covariance
#'   matrix of the auxiliar statistics in the simulated networks
#'
#' @return numeric value with the Mahalanobis distance of auxiliar stats
#'
#' @examples
#' mhd(c(2, 4) - c(1.5, 2), solve(matrix(c(1, 0.8, 0.8, 1), ncol = 2)))
mhd <- function(auxStats, invCov) {
  t(auxStats) %*% invCov %*% auxStats
}

triadCensusStd <- triadCensusStd[,stdev>0]
mhd_sim <- apply(triadCensusStd, 1, function(x) mhd(x, Phatinv))
mhd_obs <- as.numeric(mhd(net2std, Phatinv))

## v. Monte-Carlo p-value computation                                ----
# Compute the proportion of simulated networks where the distance is 
# equal or greater than the distance in the observed network.
mean(mhd_sim >= mhd_obs)

# violin plots ------------------------------------------------------------
# Fill out the missing part and run the code to obtain the violin plots

# install.packages(c("tidyverse", "ggplot2"))  # # run this line to install 
library(tidyverse)  # used: dplyr and tidyr
library(ggplot2)

# Given the array triadCensusStd, create a data frame from it in a long format, 
# do the same for the observed network statistics at time t2.
# Named the data frame "triadCensusDf" and "triadCensusObs".
# Drops statistics with variance of 0 for the plot.

triadCensusDf <- data.frame(triadCensusStd) |>
  select(where(~ var(.) > 0)) |>  # Drop statistics with zero variance
  pivot_longer(
    everything(),
    names_to = "triad", names_pattern = "^X(.+)$",
    values_to = "nnodes"
  )

# Compute the statistics of the observed network at time t2,
#  standardized using the stats from 2.4 literal i.
triadCensusObs <- # ---MISSING--- |> 
  data.frame(t(net2std)) |>
  pivot_longer(
    everything(),
    names_to = "triad", names_pattern = "^X(.+)$",
    values_to = "nnodes"
  ) |>
  filter(triad %in% unique(triadCensusDf$triad))

# The following code computes the 5% and the 95% quantiles
# of the triad counts by type
percTriad <- triadCensusDf |>
  group_by(triad) |>
  summarise(
    quant05 = quantile(nnodes, prob = 0.05),
    quant95 = quantile(nnodes, prob = 0.95)
  ) |>
  pivot_longer(
    starts_with("quant"),
    names_to = "quant", names_pattern = "quant(.+)",
    values_to = "nnodes"
  )


# The following code produces the violin plots
ggplot(triadCensusDf, aes(fct_inorder(triad), nnodes)) +
  geom_violin(trim = FALSE, scale = "width") +
  stat_summary(fun = mean, geom = "point", size = 2) +
  geom_boxplot(width = 0.2, fill = "gray", outlier.shape = 4) +
  geom_point(data = triadCensusObs, col = "red", size = 2) +
  geom_line(
    data = triadCensusObs, aes(group = 1), col = "red", linewidth = 0.5
  ) +
  geom_line(
    data = percTriad, mapping = aes(group = quant),
    col = "gray", linetype = "dashed"
  ) +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.y = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  ) +
  xlab("triad type")

```

The p-value computed in (4) suggests that the model has a bad fit, because it is below $0.05$. Considering the plot, $3$ observed values are outside the $95\%$ confidence intervals.

## Task 3

(1) (1.1)

```{r, cache=TRUE}
f1 <- as.matrix(read.csv("f1.csv", header = FALSE))
f2 <- as.matrix(read.csv("f2.csv", header = FALSE))
f3 <- as.matrix(read.csv("f3.csv", header = FALSE))
attributes <- read.csv("demographic.csv", header = TRUE)
logdistance <- as.matrix(read.csv("logdistance.csv", header = FALSE))
alcohol <- as.matrix(read.csv('alcohol.csv', header = T))

friendship <- sienaDependent(
  array(c(f1, f2, f3), dim = c(129, 129, 3))
)

gender <- coCovar(attributes$gender)
age <- coCovar(attributes$age)
logdistance <- coDyadCovar(logdistance)
alcohol <- varCovar(alcohol)

mydata <- sienaDataCreate(friendship, gender, age, logdistance, alcohol)
print01Report(mydata, modelname='Glasgow')
```

```{r, cache=TRUE}
# Tie changes between subsequent observations:
#  periods        0 =>  0   0 =>  1   1 =>  0   1 =>  1   Distance Jaccard   Missing
#   1 ==>   2     15827       237       240       208       477     0.304         0 (0%)
#   2 ==>   3     15839       228       209       236       437     0.351         0 (0%)
```

The Jaccard Index is above $0.3$ in both periods, so the data contains enough information to investigate the evolution of the friendship network.

(1.2)

```{r, cache=TRUE}
myeff <- getEffects(mydata)
myAlgorithm <- sienaAlgorithmCreate(
  projname = "friends_res",
  nsub = 4, n3 = 3000, seed = 2023
)
myeff <- includeEffects(myeff, transTrip)
myeff <- includeEffects(myeff, inPop)
myeff <- includeEffects(myeff, egoX, altX, simX, interaction1='alcohol')
myeff <- includeEffects(myeff, X, interaction1='logdistance')
```

(1.3)

```{r, cache=TRUE}
modelEv <- siena07(
  myAlgorithm,
  data = mydata, effects = myeff,
  returnDeps = TRUE,
  useCluster = TRUE, nbrNodes = 4
)
modelEv
```

The algorithm converged, because the absolute value of the maximum t-ratio of all the parameters is below $0.1$ and the overall maximum convergence ratio is below $0.2$.

```{r, cache=TRUE}
# use parallel computation
cl <- makeCluster(4) # with 4 workers

# Indegree distribution
gofEvId <- sienaGOF(
  modelEv,
  verbose = FALSE,
  varName = "friendship", IndegreeDistribution,
  cluster = cl
)

# Outdegree distribution
gofEvOd <- sienaGOF(
  modelEv,
  verbose = FALSE,
  varName = "friendship", OutdegreeDistribution,
  cluster = cl
)

# Triad census
gofEvTC <- sienaGOF(
  modelEv,
  verbose = FALSE,
  varName = "friendship", TriadCensus,
  cluster = cl
)


# Geodesic distance
GeodesicDistribution <- function(
    i, data, sims, period, groupName,
    varName, levls = c(1:5, Inf), cumulative = TRUE
) {
  x <- networkExtraction(i, data, sims, period, groupName, varName)
  require(sna)
  a <- sna::geodist(symmetrize(x))$gdist
  if (cumulative) {
    gdi <- sapply(levls, function(i) {
      sum(a <= i)
    })
  }
  else {
    gdi <- sapply(levls, function(i) {
      sum(a == i)
    })
  }
  names(gdi) <- as.character(levls)
  gdi
}

gofEvGD <- sienaGOF(
  modelEv,
  verbose = FALSE,
  varName = "friendship", GeodesicDistribution
)


plot(gofEvId)
plot(gofEvOd)
plot(gofEvGD)
plot(gofEvTC, center = TRUE, scale = TRUE)
```

Even though the model has converged, the fit is bad, because, as we can see from all the plots except the one related to the indegree distribution, the observed values are not all inside the $95\%$ confidence intervals.

```{r, cache=TRUE}
printSiena(modelEv)
```

All the included parameters are significant, except for the control effects (alcohol ego and alcohol alter). The density parameter is negative, as we expected from a social network (sparse network). The positive reciprocity parameter suggests that an actor tends to reciprocate a friendship nomination. The negative logdistance parameter suggests that there is a negative correlation between distance between students and tendency to form a tie. The negative indegree popularity suggests that there is a tendency to nominate as a friend unpopular students (low in-degree). The positive alcohol similarity effect suggests that students with similar alcohol consumption tend to be friends.

(1.4) The first hypothesis is not supported by data, because the parameter related to indegree popularity is negative. The second hypothesis is also supported by data, so we can say that students tend to be friends with pupils with similar alcohol consumption to their own. Since the estimate of the coefficient related to the logdistance is significant and negative, we can say the smaller the distance, the more likely the students are to be friends, so we do not have evidence to reject hypothesis 3.

(2) (2.1)

```{r, cache=TRUE}
alcoholbeh <- sienaDependent(alcohol, type = "behavior")
mydata <- sienaDataCreate(friendship, alcoholbeh, gender, age, logdistance)
print01Report(mydata, modelname = "Glasgowbeh")
# Moran index
moran1 <- nacf(f1, alcohol[, 1], lag.max = 1, type = "moran",
               neighborhood.type = "out", mode = "digraph")
moran2 <- nacf(f2, alcohol[, 2], lag.max = 1, type = "moran",
               neighborhood.type = "out", mode = "digraph")
moran3 <- nacf(f3, alcohol[, 3], lag.max = 1, type = "moran",
               neighborhood.type = "out", mode = "digraph")
autocorr <- rbind(moran1, moran2, moran3)
autocorr[,2]
```

We can see that there is positive autocorrelation between the friendship ties and the alcohol consumption.

```{r, cache=TRUE}
myeff <- getEffects(mydata)
myeff <- includeEffects(myeff, transTrip)
myeff <- includeEffects(myeff, inPop)
myeff <- includeEffects(myeff, egoX, altX, simX, interaction1='alcoholbeh')
myeff <- includeEffects(myeff, X, interaction1='logdistance')
myeff <- includeEffects(myeff, indeg, avSim,
                        name = "alcoholbeh", interaction1 = "friendship")
```

(2.2)

```{r, cache=TRUE}
myAlgorithm <- sienaAlgorithmCreate(
  projname = "CoevGlasgow",
  nsub = 4, n3 = 3000, seed = 2023
)

# Model estimation
modelCoev <- siena07(
  myAlgorithm,
  data = mydata, effects = myeff, 
  returnDeps = TRUE, batch = FALSE,
  useCluster = TRUE, nbrNodes = 4
)
modelCoev
```

The algorithm converged, because the absolute value of the maximum t-ratio of all the parameters is below $0.1$ and the overall maximum convergence ratio is below $0.2$.

```{r, cache=TRUE}
cl <- makeCluster(4)

# Indegree distribution
gofCoevId <- sienaGOF(
  modelCoev,
  verbose = FALSE,
  varName = "friendship", IndegreeDistribution,
  cluster = cl
)

# Outdegree distribution
gofCoevOd <- sienaGOF(
  modelCoev,
  verbose = FALSE,
  varName = "friendship", OutdegreeDistribution,
  cluster = cl
)

# Triad census
gofCoevTC <- sienaGOF(
  modelCoev,
  verbose = FALSE,
  varName = "friendship", TriadCensus,
  cluster = cl
)


# Geodesic distance
gofCoevGD <- sienaGOF(
  modelCoev,
  verbose = FALSE,
  varName = "friendship", GeodesicDistribution
)

# Behaviour distribution
gofCoevBeh <- sienaGOF(
  modelCoev,
  verbose = FALSE,
  varName = "alcoholbeh", BehaviorDistribution,
  cluster = cl
)

stopCluster(cl)

plot(gofCoevId)
plot(gofCoevOd)
plot(gofCoevGD)
plot(gofCoevTC, center = TRUE, scale = TRUE)
plot(gofCoevBeh)
```

Even when investigating the co-evolution of friendship and alcohol consumption, the model has a bad fit, because the outdegree distribution, the geodesic distribution and the triad census are not well represented by the model.

```{r}
printSienaCoev(modelCoev)
```

The estimates of the parameters shared with the previous models lead to the same conclusions. The non-significant parameter for linear shape suggests that there is no tendency to either decrease or increase alcohol consumption in general. The non-significant parameter for quadratic shape suggests that there is no tendency to form a U or inverse U shape over time. The significant positive parameter for alcoholbeh similarity suggests that students are more likely to form friendship ties to students with similar drinking habits. The significant positive parameter for alcoholbeh average similarity suggests that students adjust their alcohol consumption to that of their friends. There is no evidence that popular students tend to increase or maintain their level of alcohol consumption.

(2.3) The fourth hypothesis is not supported by the data because the coefficient related to alcoholbeh indegree is not significant. The fifth hypothesis is supported by the data, so we can say that students tend to adjust their alcohol consumption to that of their friends. The conclusions about the hypotheses in (1) do not change.

(2.4) We have evidence for both selection and influence processes. As an example, hypothesis $2$ is related to the selection process and we found evidence to support it. Similarly, hypothesis $5$ is related to an influence process (students adjusting their drinking behavior) and we found evidence to support it.

(3) Since the outdegree distribution is not well represented by the model, comparing the outdegree distribution in the observed network to the one in the simulated networks, the first results to be more skewed, so it may be necessary to let the rate function depend on the outdegrees, as specified in the RSiena manual. Additionally, another way to improve the representation of the outdegree statistic would be to use different outdegree variables for different types of individuals (e.g. individuals with different alcohol consumption habits) instead of just one variable for all individuals. 

As regards the geodesic distances, in the simulated networks they are too large compared to the observed network. Hence, we might consider adding the gwesp effect, which is an alternative expression for transitivity. By doing so, we can potentially increase transitivity and thus shorten the distance between nodes.
